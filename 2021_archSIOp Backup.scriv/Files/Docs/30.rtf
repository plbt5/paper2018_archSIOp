{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 We maintain the position that computers lack the capability for genuine understanding and, hence, need to position the human-in-the-loop as a necessary element in sIOP in order to cater for the understanding of the semantic differences between the interoperating agents. This human is required for one task only: re-establishing reciprocity. The two possible approaches for this task are, (i) to modify the own pragmatic meaning such that it can operate in a valid way on the external semantic meaning, or (ii) to modify the external semantic meaning such that it can be operated on by the existing pragmatic meaning in a manner faithful to the current state of affairs. The consequence of the first approach is that it allows external definitions to influence internal workings. This clearly breaks one of the fundamental principles of software engineering, *low coupling, high cohesion* [e.g., @Hitz1995], and should therefore only be considered as a last resort. The second approach only adapts that what was already external to the receiving software agent, and thereby doesn\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92t breach this fundamental principle. We elaborate on this approach from the perspective of the receiving agent. The task is to convert the representation of the external semantic meaning such that it becomes syntactically identical to the representation of the internal semantic meaning, *and*, that the original external ASM refers to a state of affairs that is also referred to by the state of affairs of the internal ASM when processing the external data. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In order to achieve that, we first assume that the quality of our own software agent is such that the internal semantic meaning is in coherence with the internal pragmatic meaning, i.e., that its concerning ASM is faithful to reality over the complete range of the internal semantic meaning, i.e., the data values that it is designed to process. Contrarily, we *cannot* assume that any variation on the internal semantic meaning, no matter how small, will remain in coherence with the internal pragmatic meaning. Founded on this essential disposition we conclude that aligning the external semantic meaning with the internal semantic meaning such that the former does not overlap the latter, is the only approach that can guarantee sIOP. We reflect this with the following principle:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Align the internal and external semantic meaning of the exchanged data]\\label\{dp:alignment\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 When a software agent engages in interoperation with (an)other software agent(s), establish for the exchanged data a maximal coherence between external semantic meaning and internal pragmatic meaning by formalising the alignment between the external and internal semantic meaning.   }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} application, data  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} semantics, semantic interoperability   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item On processing external data, semantics manifest themselves as the reciprocity between data and processing code;}
\par\plain {\f0\fs24\b0\i0   \\item Data are considered to carry the semantic meaning as specified by the Domain Model of the software agent;}
\par\plain {\f0\fs24\b0\i0   \\item Formalising a correspondence relation between the semantic meanings of interoperating software agents effectively connects the external semantic meaning with the internal pragmatic meaning;}
\par\plain {\f0\fs24\b0\i0   \\item By assuring that the internal semantic meaning encompasses the external semantic meaning, and by assuring that the semantic consequences of the latter extending the former are insignificant, collectively assures the semantic validity of the correspondence relation.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item The conversion from external to internal semantic meaning is specified by a correspondence;}
\par\plain {\f0\fs24\b0\i0   \\item The collection of all correspondences specify the semantic alignment that holds between a pair of interoperating agents;}
\par\plain {\f0\fs24\b0\i0   \\item Software agents that are unable to align their semantic meaning with the external semantic meaning cannot engage in sIOP without introducing phantom semantics, with unforeseen consequences in their data processing.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 A *correspondence* specifies as accurately as possible the semantic difference (out of those listed in Appendix A) that exists between a pair of related concepts, i.e., it aligns between the semantic meanings of interoperating agents. By exhaustively addressing all semantic differences that exist between both agents, the set of correspondences collectively specify the *alignment* that holds between two agents. The purpose of the alignment is to establish how the truth of expressions that are formulated in terms of agent A, can be established by using formulations in terms of agent A\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92, and to capture their potential difference as a relation. To that end we differentiate between two categories of semantic differences:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 1. *Conceptual differences*: variations that can be specified as logical relation between (constructions of) concepts from both ontologies, e.g., naming conventions or variations in structure; }
\par\plain {\f0\fs24\b0\i0 1. *Value differences*: variations in conventions on how to represent values with or without magnitudes, e.g., differences in value scales, units of measure or nominal properties.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The language used to specify the correspondences must be expressive enough to identify the atomic elements of the ontologies, to combine them into logical combinations as well as to formulate the relationship that holds between them. In [@Euzenat2007;@Scharffe2011], an investigation has been reported towards the requirements for such an alignment language, summarised as follows. A *correspondence* denotes a single particular inter-ontological relation, prescribed, and assumed to represent a semantically valid relation between both concepts, as: }
\par\pard\plain \tx720\ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{equation*\}\\label\{eq:correspondence\}}
\par\pard\plain \tx720\ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 \\mu = \\tuple\{ e, e\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92, \\theta \}}
\par\plain {\f0\fs24\b0\i0 \\end\{equation*\}}
\par\pard\plain \tx720\ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 with:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 * $\\theta \\in \\set\{=, \\sqsubset, \\sqsupset, \\disj, \\overlap \}$ specifying the *correspondence relation* that holds between entity constructions from the source, $e$, and the target, $e\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92$. The basic correspondence relations denote $=$: semantic equivalence, $\\sqsubset$: subsumption of, $\\sqsupset$: subsumes, $\\disj$: disjointness, and $\\overlap$: overlap. Although more relations can be required to include for a particular use case, such does not invalidate the general principle. Further note the correspondence relation is a directed relationship. }
\par\plain {\f0\fs24\b0\i0 * The source and target *entity constructions*, $e$, are build on the atomic elements of the ontology language. An entity construction connects concepts by applying:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0     * conceptual connectors:}
\par\plain {\f0\fs24\b0\i0         * logical connectors \\token\{AND\}, \\token\{OR\}, and \\token\{NOT\};}
\par\plain {\f0\fs24\b0\i0         * a path connector as a sequence of zero or more Object Relations, \\token\{R\}, optionally ending with an Object Property \\token\{P\}, summarised as follows: \\token\{R^*[P]\};}
\par\plain {\f0\fs24\b0\i0         * property construction operators (inverse, composition, reflexive, transitive and symmetric closures);}
\par\plain {\f0\fs24\b0\i0         * constraints (through domain, range, cardinality and value restrictions);}
\par\plain {\f0\fs24\b0\i0     * value functions:}
\par\plain {\f0\fs24\b0\i0         * mathematical calculations for, e.g., unit conversion, operating on one or more values having a magnitude in order to arrive on a value that fits the dimension(s) of use by the pragmatic meaning of the receiving agent;}
\par\plain {\f0\fs24\b0\i0         * transcriptors operating on one or more nominal values without magnitude, viz. codes that identify or categorise a certain domain aspect, e.g., }{\f0\fs24 ISO3166-alpha2}{\f0\fs24\b0\i0  two-letter codes that specify a particular country, or the blood type.}
\par\pard\plain \tx720\ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \tx720\ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 Without the conceptual connectors it is only possible to address a single concept or individual as defined by the ontology, representing an aggregation level that is relevant for the software agent but might not be relevant in terms of the interoperating agent, and hence, for their mutual sIOP. By application of conceptual connectors the architecture gains the capability to address a specific compound of individuals in either the source or target ontology that relate to the semantic difference at hand. Similarly, with the application of value functions, the architecture gains the capability to specify transformations between conventions on value representations and nominal properties.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\field{\*\fldinst HYPERLINK "scrivcmt://A2A67E6C-5E11-44F5-B545-4443160083A9"}{\fldrslt\f0\fs24\b0\i0 Current solutions}}{\f0\fs24\b0\i0  that standardise semantic solidify the understanding in the syntax of the data. In this way, semantics are carried by a data schema that is primarily designed to serialise data and to support data transfer by message construction and exchange. We consider this a significant neglect of the principle on separation of concerns, conflating the semantic interoperability concerns with the data communication concerns. The consequence of conflating these concerns is that source code which should concerned primarily with message construction, parsing, storage, and other data communication related tasks, becomes dependent on how semantics influence the syntax. In a message-oriented paradigm, for instance, any difference in structure in order to reflect the local perspective on semantic structure will have a significant impact on how to (de)compose the message. And any new data source to connect to will proliferate into a new software release. We thus observe that the current approach to data understanding results in an architecture which imposes a significant complication on interoperability (and other -ilities as well), impeding access-and-play. And despite the current limitations of AI-software to genuinely understand, a significant gain towards the software agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s access-and-play capabilities can be achieved by untangling the syntax and semantics through separation of the sIOP concerns from the data communication concerns. We propose the following design principle to its effect:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Separate semantics from communication syntax]\\label\{dp:ssoc\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 When a software agent engages in interoperation with (an)other software agent(s), resolve their semantic differences independently from the syntax of the exchanged data.   }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} data, technology  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} semantic interoperability, portability, maintainability, efficiency, usability (reuse), reliability, functionality   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item Data schemata are defined to support the (de)serialisation processes that consolidate the data communications concern;}
\par\plain {\f0\fs24\b0\i0   \\item Neglecting the principle of separation of concerns solidifies dependency between otherwise disjoint concerns, here the semantic level and the syntactic level of data communication;}
\par\plain {\f0\fs24\b0\i0   \\item Access-and-play capabilities are supported by assuring minimal impact on software code when introducing semantic modifications;}
\par\plain {\f0\fs24\b0\i0   \\item Minimising impact on software code that is concerned with data communication is realised by abstracting semantics away from the data schemata.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item Separation of concerns has a strong positive effect on software quality, including but not limited to sIOP;}
\par\plain {\f0\fs24\b0\i0   \\item Removing any dependency between semantics and data syntax enables to support multiple communication paradigms without the need to modify the semantic abstraction;}
\par\plain {\f0\fs24\b0\i0   \\item Similarly, modifications in the semantic representation, or supporting multiple semantic representations become possible without the need to modify the communication layer;}
\par\plain {\f0\fs24\b0\i0   \\item Align semantics, not data schemata: Semantic reconciliation is applied at a higher conceptual level and abstracts away from data communication schemata;}
\par\plain {\f0\fs24\b0\i0   \\item Heterogeneous semantics from multiple data sources are more easily supported;}
\par\plain {\f0\fs24\b0\i0   \\item Semantic alignments imply the need for a mediation capability between the semantic representations of the communicating agents.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ql\ltrch\loch \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\field{\*\fldinst HYPERLINK "scrivcmt://D4341080-20C5-413E-BF55-A95125F2D94A"}{\fldrslt\f0\fs24\b0\i0 Current sIOP practises}}{\f0\fs24\b0\i0  already require humans-in-the-loop to reconcile the semantic differences that occur. Often, the subject of reconciliation is the differences in data schemata, and the result of the reconciliation is laid down as a canonical data model. By applying semantic reconciliation on the conceptual level, the dependency on the (data) syntax, and vice-versa, is minimised. Moreover, by representing the result of the reconciliation as an alignment (between ontologies) as opposed to a canonical semantic model (core ontology), the influence of the peer agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s semantics on one\u8217\'92s own semantics is minimised as well. An alignment, thus, functions as an interface that enforces loosely coupled semantics by enabling semantic transparency between communicating peers. Reducing the human-in-the-loop to author an alignment only, (i) accelerates the deployment of sIOP by removing all human effort that is concerned with implementation activities, and (ii) decouples the sIOP scope to bilateral alignments only. This process has been depicted in \\cref\{fig:dt-reconciliation\}.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 ![Semantic reconciliation results in an alignment between the semantic representations of two ontologies. We defend that semantic reconciliation is a computer-aided but ultimately human-authored task.][def:DTReconciliation]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\plain {\f0\fs24\b0\i0 [def:DTReconciliation]: src\\images\\DesignTimeReconciliation.png \{#fig:dt-reconciliation width=25%\} }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0}