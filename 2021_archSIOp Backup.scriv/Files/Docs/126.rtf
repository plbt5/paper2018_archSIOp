{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 Courier New;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 **Construct redundancy** [@Wand:1993dX] occurs when more than one language construct can be used to represent the same domain concept. A language `L` is **laconic** w.r.t. to a domain `D` iff every concept in the ontology `O` of that domain is represented at most once in the metamodel of that language [@Guizzardi:2005tn]. Despite of being related, laconicity and construct redundancy are two different (even opposite) notions. On one hand, construct redundancy does not entail non-laconicity. For example, a language can have two different constructs to represent the same concept, however, in every situation the construct is used in particular models it only represents a single domain element. On the other hand, the lack of construct redundancy in a language does not prevent the creation of non-laconic models in that language. Non-laconicity at the language level can be considered as a special case of construct redundancy that does entail non-laconicity at the model level.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Construct redundancy adds unnecessarily to the complexity of the modeling language, possibly confusing the users. Non-laconicity allows redundant representations that can be interpreted as standing for a different domain element. }}