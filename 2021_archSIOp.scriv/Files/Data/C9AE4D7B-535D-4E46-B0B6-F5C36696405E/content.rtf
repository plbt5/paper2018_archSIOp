{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\fswiss\fcharset0 Helvetica;\f2\fmodern\fcharset0 CourierNewPS-ItalicMT;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\deftab720
\pard\pardeftab720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 With semantics, we refer to real world semantics (RWS) and we summarise our position towards semantics in {\field{\*\fldinst{HYPERLINK "scrivcmt://1418BCCC-2C39-4246-B8EE-8893AEA3E27E"}}{\fldrslt software from [@Brandt2021a]}}:\
\
1. Since software is incapable of genuine understanding, RWS cannot exist in software. Nevertheless, the software agent acts as transport medium for RWS between users or users and system operations, and must do so without compromising the transported cargo, viz RWS. \
2. The nature of software dictates that data and their data processing are always intimately connected. We consider the 
\f1 <$Scr_Cs::0>
\f2\i reciprocity
\f1\i0 <!$Scr_Cs::0>
\f0  between data and their processing the carrier of RWS. Any incoherent reciprocity, i.e., inconsistencies between data and their processing, equates to unfaithfulness to reality, viz semantics that are considered invalid by the current SoA in the application domain.\
3. In terms of semantics, we discern *semantic meaning*, i.e., what is said, from *pragmatic meaning*, i.e., the connection to our frame of reference and context of use. In terms of software, we consider *data* the carrier for semantic meaning, and their *data processing* carrier for pragmatic meaning. For example, data token \\token\{S\} with value \\token\{t = 38.9\\celsius\} represents semantic meaning whereas data processing token \\token\{P1\} with value \\token\{t > 37.0\\celsius\} $\\to$ \\token\{fever\} represents pragmatic meaning. \
4. 
\fs22 \AppleTypeServicesU1 Semantic coherence builds on the consistency with which the semantic and pragmatic meanings commit to the same distinctions in their shared reality, and only require each other's knowledge in executing their reciprocity (faithfully).
\fs24 \AppleTypeServicesU0 \
5. The active (processing) part of an agent produces agent behaviour. We separate behaviour into a 
\f1 <$Scr_Cs::0>
\f2\i comprehension
\f1\i0 <!$Scr_Cs::0>
\f0  process and 
\f1 <$Scr_Cs::0>
\f2\i achievement
\f1\i0 <!$Scr_Cs::0>
\f0  processes, the latter specifying how to accomplish the agent\'92s purpose, based on the former that mirrors the current state of affairs (SoA) in the DoA and the agent\'92s own background knowledge. The resulting simple software model emerges as  \
\\resizebox\{\\linewidth\}\{!\}\{\\textsf\{\\textbf\{\\small Input\\ensuremath\{\\twoheadrightarrow\}\\colorbox\{gray!30\}\{Comprehension\}\}\}\\stackedcondtext\{Achievement$_i$\}\{Achievement$_j$\}\\textsf\{\\textbf\{\\small Output\}\}\} where \\textsf\{\\colorbox\{gray!30\}\{\\small shaded\}\} represents behaviour, \\textsf\{\\small non-shaded\} represents static structures and \\textsf\{\\textbf\{\\small bold\}\} represents semantics. For instance, consider data token \\token\{S\} and data processing tokens \\token\{P1\} and \\token\{P2\}: \
    * \\token\{S\} ::[|temperature]: \\token\{t = 38.9\\celsius\}\
    * \\token\{P1\} ::[|fever]: \\token\{t > 37.0\\celsius\} $\\to$ \\token\{fever\}\
    * \\token\{P2\} :: \\token\{fever\} $\\to$ \\token\{raiseAlarm(now)\}  \
We consider \\token\{S\} and \\token\{P1\} a representation of comprehension and \\token\{P2\} one of achievement.\
6. Note that semantic meaning, e.g., \\token\{S\}, is in itself insufficient to draw conclusions and select particular achievement, since its implication on the software agent depends on the pragmatic meaning that applies. When considering pragmatic meaning \\token\{P1\}, it establishes [|fever] in a human context, whereas \\token\{P3\} with \\token\{t > 39.7\\celsius\} $\\to$ \\token\{fever\} also represents pragmatic meaning, but in a feline context instead, leading to its negation [|$\\righthalfcap\\;$fever] in combination with \\token\{S\}. Hence, no alarm is raised. Different comprehension leads to different achievement.\
7. The central disposition of reciprocity in software semantics emerges as an *Atomic Semantic Monolith* (ASM), established with the explicit purpose to guarantee the coherence between the data (semantic meaning) and their processing code (pragmatic meaning). The ASM achieves comprehension about its particular semantic meaning in the context of its appropriate use. For instance, (\\token\{S\};\\token\{P1\}) and (\\token\{S\};\\token\{P3\}) represent two distinct ASMs for two distinct uses of temperature data.\
8. The collective ASMs compose the agent\'92s Domain Model (DM), and provides the software agent with the level of comprehension necessary to decide upon its achievement (to achieve the agent\'92s objectives) under the current SoA. \
9. Where comprehensive behaviour is specified by the DM, the achievement behaviour is specified by (parts of) the System Model (SM). We consider the SM 
\f1 <$Scr_Cs::0>
\f2\i semantically grounded
\f1\i0 <!$Scr_Cs::0>
\f0  in the DM if all terms that are used by the SM 
\f1 <$Scr_Cs::0>
\f2\i and
\f1\i0 <!$Scr_Cs::0>
\f0  refer to the SoA and DoA, get their comprehension from the DM.\
\
}