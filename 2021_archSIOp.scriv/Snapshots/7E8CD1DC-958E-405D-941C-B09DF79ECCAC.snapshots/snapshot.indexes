<?xml version="1.0" encoding="UTF-8"?>
<SnapshotIndexes Version="1.0" BinderUUID="7E8CD1DC-958E-405D-941C-B09DF79ECCAC">
    <Snapshot Date="2018-08-09 13:33:34 +0200">
        <Title>Incl Grice's semantic and pragmatic meaning </Title>
        <Text>We take the position that strong AI is not yet available, if ever [@XiuquanLi2017], and conclude that weak AI is essentially a token-based machine without the ability to close the gap between token and reality. Also called the Grounding Problem [@Harnad1990], addressing this fundamental distinction in software engineering is at best extremely narrow [@Steels:2008tr], or not present at all [@Cregan2007]. This implies that the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This leads us to the conclusion that semantics can not ever exist in software when based on weak AI. Unfortunately, we make do with weak AI and its beheaded sign necessarily. This is confirmed by the software engineering discipline herself since it consistently speaks of ‘models that represent reality’ without factoring the conceptualisation into the equation, e.g., “*a model is a representation of reality intended for some definite purpose*” and similar quotes that are collected by [@Aßmann2006]. Consequently, the edges that connect the conceptualisation remain vague or necessarily conflate on the then explicit relationship between the model and reality, depicted in \cref{fig:software-models-reality}.    

![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]

During software engineering the semeiosis is taken care of by the software engineer whom implicitly performs the conceptualisation and explicitly represents the conceptualisation into tokens, i.e., *models*. From the many models that software engineering typically generate we focus on two types: those modelling the *information elements* that play a role (information/data models), and those modelling the *operations that apply* on these information elements (process/business models). It is one of the responsibilities of the software engineer to keep the information model and the process model in strict coherence with each other. Subsequently the process models become code (operations, algorithms) and the information models become data. Guaranteeing that the coherence also applies at this binary level is particularly important because at run-time the software engineer has left the building, and with him the conceptualisation vertex and the subsequent capability for semeiosis. What remain are the code and the data, the relation between the two being essentially non-existent and at best implicit. The coherence between the state of affairs in the world, viz. the data, and how this data should be processed, is the one and only means to keep the software from failing.          


In fact, the latter falls apart in two other model categories, viz. models that directly operate on information in order to infer other facts (conclusions), and models that act on those conclusions and initiate some business oriented activities. We will call the latter the *pragmatics* of the software agent, and we will not further elaborate on that. Regarding the former two models we explain them to represent the two subtypes of meaning according to [@Grice:1991BT;@Schulz2007]: firstly, *semantic* meaning, meaning as conveyed by the tokens, explained by Grice as *what is said*, are directly related to the information models. Secondly, *pragmatic* meaning, explained by Grice as what a speaker adds by implication and/or intention when uttering a sentence in a particular context [@smith2003, p.50], are directly related to models that infer new data. For instance, consider a heart rate reading of 128BPM. The semantic meaning that is carried is exactly what is said, viz. the number of times a heart beats during one minute. In case of the pragmatic meaning, though, the same bits will refer to a very different health condition in the context of a sleeping elderly (triggering an alarm) than in the context of a sleeping new-born (indicating perfect health). We like to consider the pragmatic meaning as the meaning that is required to draw conclusions, demanding the specific *context of use*. 
 


However, as soon as the semeiosis has taken place,  As we have seen in the previous section, linking between triangles exists horizontally and vertically alike. In this case, subsequent software engineering will conceptualise the models in different representational metalevels as well as built different levels of abstractions and generalisations.      



the  the *signification* of the software agent. Although genuine semantics does not exist in software, a software agent can definitely fail in its signification part. When such failure happen  


one of her major responsibilities are to assure that the data and the code operating on that data remain coherent with each other. In fact, one of the main arguments for the introduction of object-orientation (OO) was to dispose of a means that could enforce this “data-code coherence” in a natural way. Introducing a class to represent a particular entity in reality, and its methods that operated on it, enforces the software engineer to maintain one single conceptualisation that is represented by a set of two tightly coupled tokens: the data and the code operating on that data.   

  


Interestingly, according to [@Grice:1991BT;@Schulz2007], two subtypes of meaning exist:  

Elaborate on the reciprocity as software semantics

Elaborate on OO to consolidate the reciprocity; take the class as example of a semantic monolith, the minimal, atomic one.

&lt;!-- page additions --&gt;
[def:softmodelsreal]: src\images\SoftwareModelsReality.png {#fig:software-models-reality}</Text>
    </Snapshot>
</SnapshotIndexes>