{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that weak AI is essentially a token-based machine without the ability to close the gap between token and reality. Also called the Grounding Problem [@Harnad1990], addressing this fundamental issue in software engineering about semantics is at best extremely narrow [@Steels:2008tr], or not present at all [@Cregan2007]. This implies that the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed by the software engineering discipline herself implicitly, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. Consequently, the edges that connect the conceptualisation remain vague or necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. In terms of [@Quine:1953er] above, we have beheaded the sign and cut-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94, we deleted that what \u8220\'93we *say* there is\u8221\'94. We have removed the \u8220\'93ontological level\u8221\'94 [@Guarino1994b], and with that our \u8220\'93terminological competence [that] can be gained by formally expressing the ontological commitment of a knowledge base\u8221\'94 (ibid.). However, since we make do with weak AI and therefore with this beheaded sign necessarily, we must conclude that genuine semantics can not ever exist in current software agents.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 During the use of a software agent the semeiosis is taken care of by the human-in-the-loop, viz. the end user at the human-machine interface (HMI) whom interprets the tokens that are displayed (subjectivation). During development of a software agent the semeiosis is taken care of by another human-in-the-loop, viz. the software engineer whom implicitly performs the conceptualisation and explicitly represents this conceptualisation into tokens, i.e., *models*. Consequently, all models are representations of the engineers\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92 conceptualisations. From the many models that software engineering typically generates we focus on a pair of models that constitute the engineers\u8217\'92 semantics: the }{\field{\*\fldinst HYPERLINK "scrivcmt://C4387A10-A79E-4C0A-9399-864D8A622782"}{\fldrslt\f0\fs24\b0\i0 information or data models}}{\f0\fs24\b0\i0  that refer to the *information entities* in reality, paired with the }{\field{\*\fldinst HYPERLINK "scrivcmt://555DAEC1-F737-4AC3-8106-1797C917D453"}{\fldrslt\f0\fs24\b0\i0 process or business models}}{\f0\fs24\b0\i0  that represent the *event entities* that operate on the information entities. Data processing is in its bare form nothing more than tokens that follow a specific language grammar. This bare form is a representation of its quintessence, viz. a run-time notion on the proper way to operate on the data. Together, these models comprise the smallest atomic union that can represent meaning, indicated by [@Grice:1991BT] as a twofold: the }{\f1\fs24\b0\i1 semantic}{\f0\fs24\b0\i0  meaning, or \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93what is said\u8221\'94, and the }{\f1\fs24\b0\i1 pragmatic}{\f0\fs24\b0\i0  meaning, what we like to understand as \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93how it relates to our intentions\u8221\'94. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) denotes the smallest, highest grained pair of models (a data model and a data processing model) that remains faithful to the entity in reality that it refers to.}
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 At the modelling level, semantics still exist by virtue of the designer. However, when the software agent is subsequently compiled, its binary code originate from the process model of the model pair (operations, algorithms), and the memory allocation for the data originates from the information model of the model pair (size, format, encoding). At this binary level the software engineer has left the building, and with her the conceptualisation vertex and the subsequent capability for semeiosis and, thus, semantics. In other words, at binary level we have lost the capability to verify the semantic coherence between the code and the data while the reciprocity between data and software code determines the semantic validity of the data processing. For instance, consider a data element $t$ to represent temperature, and a data algorithm to establish fever, e.g., `t > 37.0` $\\to$ `fever`. The one and only means to keep the software from failing is that both the data and the algorithm (i) are expressed in the same unit of dimension ($\\si\{\\degree\}C$ in this example), apply the same (ii) resolution and (iii) accuracy, to name a few obvious constraints. We, therefore, take the stance that semantics can only exist in software by virtue of the semeiosis by the human-in-the-loop, while in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. Still, the software agent acts as transport medium for the semantics as intended by the software engineer to the semantics as experienced by the end user at the HMI. We therefore consider the coherence between data models and data processing models essential for enforcing the software agent to maintain a semantic valid reciprocity between binary code and the data it operates on. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 This leads to the definition of a (normative [@Greefhorst2011]) }{\f0\fs24\b0\i0 design principle}{\f0\fs24\b0\i0  to its effect:}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic coherence principle]\\label\{dp:semantic-coherence-principle\}}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Establish explicit coherence between the models that are contained in a semantic monolith.}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} (semantic) accuracy, reusability, manageability, understandability }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\item Semantics in software agents are necessarily reduced to, and emerge from, the reciprocity between the data and the binary code that operates on them;  }
\par\plain {\f0\fs24\b0\i0 \\item Without explicitly addressing -- at modelling level -- \\textbf\{all\} facets that influence the coherence between the data on the one hand, and the operations that apply on them on the other, the software agent cannot guarantee to maintain the reciprocity between them at the binary level;}
\par\plain {\f0\fs24\b0\i0 \\item Without maintaining the reciprocity between binary code and the data it operates on, the semeiosis performed by the end user on the result of the data processing and their subsequent semantics cannot be guaranteed to be similar as intended by the software engineer.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\item The coherence principle is a necessary condition for supporting semantic interoperability;}
\par\plain {\f0\fs24\b0\i0 \\item The scope of semantic validity \\& accuracy is addressed explicitly and can be referred to;}
\par\plain {\f0\fs24\b0\i0 \\item Reuse of data often implies reuse of the data processing code, and vice versa. Having established explicit coherence improves the quality of data and code reuse, and facilitates the verification that the scope of the semantic validity \\& accuracy applies in the new context as well;}
\par\plain {\f0\fs24\b0\i0 \\item manageability ...?}
\par\plain {\f0\fs24\b0\i0 \\item understandability ...?}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 Coherence between models can be established with use of a single unique reference against which the truth of the expressions of both models can be verified. In semiotics, this single unique reference is considered reality, as indicated in \\cref\{fig:semiotic-triangles\}(b) by the *trueness* characteristic. Except as toy example in [@Steels:2008tr], this is clearly not possible. The *correctness* characteristic is the only alternative left, taking the conceptualisation node as its principle point of reference, as depicted in \\cref\{fig:single-semantic-reference\}. This is exactly what the mathematical branch of *formal semantics* achieves [@Gamut1991; @Genesereth:1987dg] with its three main characteristics, viz. connecting (i) an abstract syntax of a language to (ii) a domain of interpretation (usually a set theoretic framework) by defining (iii) an interpretation function from the abstract syntax onto the set theoretic framework. In terms of the semiotic triangle, \\cref\{fig:semiotic-triangles\}(b), this implies the following:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 (i) the *representation* node represents models that can be formulated by use of an abstract syntax (and grammar) as its modelling language. In this reading, a model is a particular constellation of tokens that represent a particular state of affairs;}
\par\plain {\f0\fs24\b0\i0 (ii) a particular *conceptualisation* can be mathematically formulated as a specific constellation of (unnamed) individuals, sets of individuals, and sets of sets; }
\par\plain {\f0\fs24\b0\i0 (iii) the *subjectivation* edge can be formulated as the interpretation function that assigns a mapping from modelling language tokens onto the set elements, enabling the evaluation of a specific model against the intended conceptualisation from (i). }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Formal semantics thus provides a means to formulate a particular conceptualisation as principle point of reference. The particular conceptualisation is then used to establish the coherence between two models. In the remainder of this text we will refer to the formulation of the reference conceptualisation as a *conceptual model*.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Maintaining the reciprocity between data and data processing models through a single semantic reference.][def:ssref]}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, we explain software semantics as the reciprocity between data and software code, realised by maintaining the coherence between pairs of data and data processing models, by applying formal semantics to formulate a particular conceptualisation as semantic reference, and interpretation functions which perform the subjectivation from the data and operation models to that reference.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 <2nd Principle: Make the ASM as small as possible, but not smaller than required to express a semantic element. Too vague, yet. Not necessary to convey the primary message, imo.>}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <Elaborate on OO to consolidate the reciprocity; take the class as example of a semantic monolith, the minimal, atomic one.>}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 [def:ssref]: src\\images\\SingleSemanticReference.png \{#fig:single-semantic-reference\}}}